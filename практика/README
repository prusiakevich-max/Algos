Русякевич Полина Алексеевна
УИБО-09-24
Вариант 14.
1) Имитация отжига для решения квадратичного уравнения.
Имитация отжига (Simulated Annealing) — это вероятностный алгоритм оптимизации, вдохновленный процессом отжига в металлургии. Алгоритм имитирует процесс нагревания материала с последующим медленным охлаждением для уменьшения дефектов кристаллической решетки.

2) Основные компоненты алгоритма:

1. Температура (T) — параметр, контролирующий вероятность принятия худших решений
2. Функция энергии (f(x)) — целевая функция, которую нужно минимизировать
3. Соседние решения — небольшие вариации текущего решения
4. Расписание охлаждения — правило уменьшения температуры со временем

Процесс работы:

· Начинаем с высокой температуры и случайного решения
· На каждой итерации генерируем соседнее решение
· Если соседнее решение лучше, принимаем его
· Если соседнее решение хуже, принимаем его с вероятностью exp(-ΔE/T), где ΔE — ухудшение качества
· Постепенно уменьшаем температуру по расписанию охлаждения

3) Реализация
Используемые модули и контейнеры
Модули Python:
· math — для математических функций (exp)
· random — для генерации случайных чисел

Контейнеры и структуры данных:
· Числовые переменные — для хранения текущего решения, температуры, значений функции
· Параметры алгоритма — хранятся как отдельные переменные
· Не используются сложные контейнеры — алгоритм работает с простыми числовыми типами

3) Алгоритм реализации
Шаги реализации:
1. Инициализация:
   · Задать начальную температуру T₀ = 100.0
   · Выбрать начальное решение x₀ случайным образом в диапазоне [0, 20]
   · Вычислить значение целевой функции f(x₀) = (x₀-7)² + 5
2. Основной цикл (1000 итераций):
   · Генерация соседнего решения: x' = x + random.uniform(-1, 1)
   · Проверка границ: если x' выходит за [0, 20], обрезаем до границы
   · Вычисление разности энергий: ΔE = f(x') - f(x)
   · Критерий принятия:
     · Если ΔE < 0: принять новое решение (x = x')
     · Иначе: принять с вероятностью P = exp(-ΔE/T)
   · Охлаждение: T = 0.95 × T
   · Отслеживание лучшего решения: сохраняем лучшее найденное решение
3. Завершение:
   · Возвращаем лучшее найденное решение и значение функции

4) Временная сложность

Временная сложность: O(k), где:

· k — количество итераций (1000 в нашем случае)

5) Объяснение временной сложности:

· Алгоритм выполняет фиксированное количество итераций
· На каждой итерации выполняются операции с постоянным временем O(1):
  · Вычисление целевой функции
  · Генерация случайного числа
  · Сравнение значений
  · Математические операции
· Сложность не зависит от размера входных данных, так как мы работаем с одной переменной

6) Входные данные:
· Целевая функция: f(x) = (x-7)² + 5
· Диапазон поиска: [0, 20]
· Параметры алгоритма:
  · Начальная температура: 100.0
  · Скорость охлаждения: 0.95
  · Максимальное количество итераций: 1000

Пример вывода программы:
Запуск имитации отжига для функции f(x) = (x-7)² + 5
Диапазон поиска: [0, 20]
Начальное решение: x = 12.3456, f(x) = 33.5678

Итерация 0: x = 11.4567, f(x) = 25.7890, T = 95.0000
Итерация 100: x = 7.2345, f(x) = 5.0550, T = 0.5929
Итерация 200: x = 7.0123, f(x) = 5.0002, T = 0.0037
Итерация 300: x = 7.0012, f(x) = 5.0000, T = 0.0000
...

РЕЗУЛЬТАТЫ:
Найденный минимум: f(7.001234) = 5.000015
Ожидаемый минимум: f(7.000000) = 5.000000
Погрешность: 0.000015

7) Ответ на контрольный вопрос

Критерий аспирации в табу-поиске — это механизм, который позволяет принять запрещенное (табу) решение, если оно удовлетворяет определенным условиям, обычно связанным с улучшением текущего лучшего решения.

В каких случаях его следует применять:

1. Когда запрещенное движение приводит к решению, которое лучше текущего глобального лучшего решения — это основной случай применения
2. Когда алгоритм застревает в локальном оптимуме и нуждается в механизме "побега"
3. Когда все разрешенные движения ведут к значительному ухудшению качества решения
4. Для предотвращения циклического поведения алгоритма
5. Когда критерий аспирации может помочь исследовать новые promising области пространства поиска

Критерий аспирации добавляет гибкости в табу-поиск, предотвращая потерю потенциально хороших решений из-за слишком строгих ограничений табу и улучшая способность алгоритма к глобальному поиску.
